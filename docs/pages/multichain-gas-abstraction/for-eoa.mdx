# Paying for Gas With ERC20 Tokens From EOAs

Blockchain transactions traditionally require native tokens (like ETH) to pay
for gas, creating a significant barrier for users who may only hold ERC20 tokens
like USDC. Biconomy's ERC20 gas payment system solves this problem by
allowing users to pay for transaction execution using their ERC20 tokens
directly from standard Externally Owned Accounts (EOAs). This approach
works with any regular EOA walletâ€”no special wallet implementation or
upgrades required. 

Users simply sign a standard ERC20 transfer transaction,
and behind the scenes, this single signature initiates complex operations
without requiring any native tokens. This system is fully backwards
compatible with existing wallets and doesn't require users to switch to
smart contract wallets or learn new transaction patterns. The result
is a seamless user experience where blockchain complexity is abstracted
away, and users can interact with dApps using only the tokens they
already have.

:::info[Supported Tokens]
The support for tokens paying for gas from EOAs is not universal. 

There are two prerequisites:

1. The token is `ERC20Permit` compliant.
2. The execution node is willing to accept is as payment for gas.
:::

## Example Using USDC to Pay for Transaction on Optimsim

Using Fusion execution, you can allow users to:

- Pay for transaction fees using USDC instead of ETH
- Execute transactions without holding native tokens
- Enjoy a simplified UX with fewer approval steps

## Prerequisites

- A private key for testing (use environment variables in production)
- USDC tokens on Optimism
- Basic understanding of AbstractJS SDK

## Implementation

```javascript
import {
  createMeeClient,
  toMultichainNexusAccount,
  toFeeToken,
  mcUSDC,
} from "@biconomy/abstractjs";
import { http, parseUnits, encodeFunctionData, erc20Abi } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { optimism } from "viem/chains";

const main = async () => {
  // Initialize account and client
  const eoa = privateKeyToAccount("0x...your_private_key...");
  const oNexus = await toMultichainNexusAccount({
    signer: eoa,
    chains: [optimism],
    transports: [http()],
  });
  const meeClient = await createMeeClient({
    account: oNexus,
  });

  // Define the transaction we want to execute
  // This example calls a hypothetical DeFi protocol
  const targetProtocolAddress = "0x123...your_target_contract_address";
  const actionInstruction = await oNexus.build({
    type: "default",
    data: {
      chainId: optimism.id,
      calls: [
        {
          to: targetProtocolAddress,
          data: encodeFunctionData({
            abi: [
              /* Your contract ABI */
            ],
            functionName: "someFunction",
            args: [
              /* Your arguments */
            ],
          }),
        },
      ],
    },
  });

  // Define how much USDC to use
  const usdcAmount = parseUnits("0.1", 6); // 0.1 USDC

  // Define the user's transaction - this is what the user will actually sign
  // It's simply a transfer of USDC that kicks off the whole process
  const userTransaction = {
    tokenAddress: mcUSDC.addressOn(optimism.id),
    amount: usdcAmount,
    chainId: optimism.id,
  };

  // Get a quote for executing the transaction using USDC as fee token
  const quote = await meeClient.getFusionQuote({
    trigger: userTransaction, // The user's USDC transfer that initiates everything
    feeToken: toFeeToken({
      chainId: optimism.id,
      mcToken: mcUSDC,
    }),
    instructions: [actionInstruction], // What happens after the user's transaction
  });

  console.log(`Estimated cost: ${quote.quote.paymentInfo.tokenValue}`);

  // Execute the transaction
  const { hash } = await meeClient.executeFusionQuote({
    fusionQuote: quote,
  });

  console.log(`Transaction started: ${hash}`);

  // Wait for transaction to complete
  const receipt = await meeClient.waitForSupertransactionReceipt({ hash });
  console.log(`Transaction completed: ${receipt}`);
};

main().catch(console.error);
```

## How It Works

1. **User Signs One Transaction**: The user simply signs a transaction to transfer a small amount of USDC
2. **Behind the Scenes Magic**: This USDC transfer automatically triggers your actual transaction
3. **Fee Payment**: The USDC is used to pay for all gas fees instead of requiring ETH
4. **Transaction Execution**: Your target transaction executes on Optimism without the user needing ETH

## Key Components

### The User Transaction

```javascript
const userTransaction = {
  tokenAddress: mcUSDC.addressOn(optimism.id),
  amount: usdcAmount,
  chainId: optimism.id,
};
```

This represents the only transaction the user actually signs - a simple USDC transfer. When the user signs this transaction, they're also implicitly authorizing the more complex transaction you want to execute.

### What Happens After The User's Transaction

```javascript
instructions: [actionInstruction];
```

This defines what should happen automatically after the user's USDC transfer. It could be:

- Interacting with a DeFi protocol
- Swapping tokens
- Executing an NFT purchase
- Any other on-chain action

### Fee Token Configuration

```javascript
feeToken: toFeeToken({
  chainId: optimism.id,
  mcToken: mcUSDC,
});
```

This tells the system to use USDC on Optimism to pay for all execution costs, so users don't need ETH.

### Fusion Quote

The `getFusionQuote` call calculates the estimated cost of execution in USDC terms, including:

- Gas fees for the actual transaction
- Swap costs for converting USDC to ETH
- Relayer service fees

## Best Practices

1. **Explain the User Experience**: Make it clear to users that they only need to sign a USDC transfer, and your application will handle everything else
2. **Amount Calculation**: Request slightly more USDC than the estimated fee to account for price fluctuations
3. **Error Handling**: Implement proper error handling for cases where fees change or transactions fail
4. **Transaction Monitoring**: Use `waitForSupertransactionReceipt` to monitor execution status

## Advanced Use Cases

This pattern can be extended to:

- Execute multiple operations in sequence after the user's single transaction
- Create cross-chain experiences where users only sign once
- Build complex DeFi interactions with a simple user experience

By using this approach, you can create a seamless experience where users interact with Optimism dApps without ever needing to hold ETH.

## Technical Detail: How Fusion Works

Behind the scenes:

1. When the user signs the USDC transfer transaction, we append a cryptographic commitment to the real transaction we want to execute
2. When the USDC transfer is detected on-chain, Biconomy's infrastructure verifies this commitment
3. The system then executes your actual transaction, paying for gas with the USDC
4. All this happens without the user needing to know about the complexity
