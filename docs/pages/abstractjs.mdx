# `AbstractJS` SDK

`AbstractJS` is the ultimate SDK for building solutions on top of smart accounts, enabling developers to effortlessly build
apps which leverage:

- [Account Abstraction]()
- [Chain Abstraction]()
- [Gas Sponsorships]()
- [Cross-Chain Gas Sharing]()
- [Fast Cross-Chain Exection With Intents]()
- [Cross-Chain Messaging]()
- [Multichain Execution.]()

Built on top of the industry-standard `viem` SDK, AbstractJS enables developes to seamlessly interact with:

- Biconomy [Modular Execution Environment](/mee/mee)
- ERC4337 [Bundler & Paymaster infrastructure](/legacy/overview)


:::tip[Open-Source and Vendor Neutral]
`AbstractJS` is infrastrucure and account neutral. You can use it with [Biconomy Nexus]() account or with alernative
smart account providers (Safe, Kernel, ...) as well as with a multitude of infrastructure environments such as
Biconomy MEE or ERC4337 Bundlers & Paymasters (Biconomy, Pimlico, ...)
:::

:::info
AbstractJS is open-source and distributed under an MIT licence, with all source files being available on [GitHub](https://google.com)
:::


## Manage Smart Accounts
AbstractJS enables developers to deploy and manage Modular Smart Accounts. The SDK is vendor neutral and supports 
both Biconomy Nexus account as well as alternative account implementations. 

### Multichain Smart Account Management

Deploying and managing smart account deployments across multiple chains can be a pain.
AbstractJS comes with buil-in utilities to [handle smart account deployment on multiple chains]()

:::info
This is not a full code example. To start implementing plase refer to [MEE Quickstart](./mee/mee) or 
[AA Quickstart](./legacy/quickstart). Not sure where to start? Read our [Choosing Infrastructure Guice](./mee/mee)
:::
```ts
// Wraps a Nexus Smart Account deployment on Polygon, Optimism and Base
const mcNexus = await toMultichainNexusAccount({
  chains: [polygon, optimism, base],
  signer: signer,
});
```

## Use Modular Execution Environments and Bundlers/Paymasters

AbstractJS supports transaction execution through Biconomy Modular Execution Environment or
through ERC4337 Bundlers and Paymasters.

### Modular Execution Environment (MEE)

Biconomy [Modular Execution Environment]() (MEE) enables developers to execute complex transaction and intent sequences across 
multiple blockchains with a single user signature.

:::info
This is not a full code example. To start implementing plase refer to [MEE Quickstart](./mee/mee) or 
[AA Quickstart](./legacy/quickstart). Not sure where to start? Read our [Choosing Infrastructure Guice](./mee/mee)
:::
```ts

// Modular Execution Environment Client
const meeClient = createMeeClient({
  account: mcNexus // Multichain Nexus account wrapper
})

// Get quote for execution
const quote = await getQuote(meeClient, {
  instructions: [
    {
      calls: [ to: zeroAddress, gasLimit: 100_000n, value: 0n ],
      chainId: optimism.id // Transaction on Optimism
    },
    {
      calls: [ to: zeroAddress, gasLimit: 100_000n, value: 0n ],
      chainId: base.id // Transaction on Base
    },
  ],
  feeToken: {
    address: mcUSDC.deploymentOn(base.id).address, // USDC address on Base
    chainId: base.id // Pay for gas on Base
  }
})

// Execute entire sequence of actions across multiple 
// blockchains with a single user signature.
const receipt = await executeQuote(meeClient, { quote })
```

### ERC4337 Bundlers and Paymasters

Bundlers and Paymasters enable [gas sponsorship](), [paying for gas with ERC20 tokens]()
and [single-chain batch execution]()

:::info
This is not a full code example. To start implementing plase refer to [MEE Quickstart](./mee/mee) or 
[AA Quickstart](./legacy/quickstart). Not sure where to start? Read our [Choosing Infrastructure Guice](./mee/mee)
:::
```ts
const nexusClient = await createSmartAccountClient({
  signer: account,
  chain: baseSepolia,
  transport: http(),
  bundlerTransport: http(bundlerUrl),
  paymaster: createBicoPaymasterClient({ paymasterUrl }),
});

const hash = await nexusClient.sendTransaction({
  calls: [
    {
      to: "0xf5715961C550FC497832063a98eA34673ad7C816",
      value: parseEther("0"),
    },
  ],
});
const receipt = await nexusClient.waitForTransactionReceipt({ hash });
```

## Multichain Utilities
AbstractJS comes built-in with utility types and functions, making it easy for developers to work in a multichain
environment.

### Multichain Contract Mapping
AbstractJS exposes functions for wrapping smart contract deployments across multiple chains in a single object, enabling
developers to quickly encode actions on any chain.

```ts
const mcAAVE = getMultichainContract({
  abi: parseAbi([
    "function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode)",
  ]),
  deployments: [
    ["0x794a61358D6845594F94dc1DB02A252b5b4814aD", optimism.id],
    ["0xA238Dd80C259a72e81d7e4664a9801593F98d1c5", base.id],
  ],
});
```

### Fetching Unified ERC20 Balance
A single function call to fetch a unified balance across all supported chains

```ts
const unifiedBalance = await getUnifiedERC20Balance({
    multichainERC20: mcUSDC,  // Your multichain token contract
    multichainAccount: mcNexus // Your multichain account
});
```

### Bridging Plugins
AbstractJS exposes pre-built plugins for interacting with bridges such as Across or LiFi. Utility functions
can encode multiple bridging transactions at the same time - when users need to fetch funds from multiple chains.

#### Triggering an Across intent with a built-in plugin

```ts
import { AcrossPlugin } from "./plugins";

AcrossPlugin.encodeBridgeUserOp({
  bridgingAmount: parseUnits('10', 6),
  fromChain: optimism,
  toChain: base,
  multichainAccount: mcNexus,
  multichainToken: mcUSDC
})
```

#### Calculating optimal bridging / intent routes

AbstractJS has utilities to help you calculate optimal routes for moving
funds from one chain to another.

```ts
buildMultichainBridgingInstructions({
  amount: parseUnits('10',6),
  bridgingPlugins: [AcrossPlugin],
  multichainAccount: mcNexus,
  toChain: optimism,
  unifiedBalance: await getUnifiedERC20Balance({
    multichainAccount: mcNexus,
    multichainERC20: mcUSDC
  }),
  isTxFeePaidWithTokenBeingBridged: false
})
```

## Effortless Single-chain and Multi-chain Orchestration

What used to take thousands of lines of code, can be achieved in a dozen lines of code with AbstractJS. Let's
check an example of a transaction which:

1. Pays for gas with USDC on Base
2. Moves USDC from multiple chains to Optimsim
3. Approves AAVE to use USDC on Optimism
4. Supplies to AAVE on Optimsim


```ts
const sTx = supertransaction({
  account: mcNexus,
  feeToken: mcUSDC.on(base),
  instructions: [
    await requireERC20Balance({
      token: mcUSDC,
      chain: optimism,
      providedAmount: supplyAmount,
    }),
    mcUSDC.write({
      chain: optimism,
      functionName: "approve",
      args: [mcAAVE.deploymentOn(optimism), inTimeBalanceOf(mcUSDC)],
    }),
    mcAAVE.write({
      chain: optimism,
      functionName: "supply",
      args: [
        mcUSDC.addressOn(optimism),
        inTimeBalanceOf(mcUSDC),
        zeroAddress,
        0,
      ],
    }),
  ],
});
```

## Multichain Batch Execution for EOAs

AbstractJS comes with built-in support for the [Biconomy Fusion]() module - enabling developers to execute
batch transactions across multiple chains from user EOA accounts - with a single signature.

The Fusion Module gives regular EOAs the ability to batch execute transactions
across one or multiple chains, while paying for gas on only one chain!

#### Before Fusion
❌ Three user signatures <br/>
❌ User needs to have gas on two chains<br/>
❌ User needs to wait for the bridge to finish before signing the second tx

#### After Fusion
✅ One user signature<br/>
✅ Needs gas on only one chain<br/>
✅ Set and forget: User signs and all transactions are executed fully

```ts
const signedFusionQuote = await signFusionQuote(meeClient, {
  // Transfer required funds from EOA to Companion SCA
  trigger: mcUSDC.on(optimism.id).transfer([
    mcNexus.deploymentOn(optimism.id).address, // smart account instance on Base
    transactionUsedAmount, // amount used by the batch execute
  ]),
  // After receiving funds, execute batch transactions
  // across one or more chains
  quote: await getQuote(meeClient, {
    instructions: instructions, // e.g. bridge from Optimism to Base, then supply to Morpho pool
    feeToken: {
      // Pay for extra execution in any token
      address: paymentToken,
      chainId: paymentChain.id,
    },
  }),
});
```
