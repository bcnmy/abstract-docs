:::tip[In Development]
The Biconomy MEE stack is still undergoing audits and will be in production at the end of Q1/25.
:::

# Modular Execution Environment (MEE)

## Intro

Modular Execution Environments (MEEs) are an evolution of the Bundler/Paymaster
infrastructure introduced with the [ERC4337]() standard. With MEEs and Smart
Accounts, users can leverage all functionalities offered by Bundlers and Paymasters
such as:

- [Sponsor transactions for users](/tutorials/gasless).
- [Pay for gas with ERC20 tokens](/tutorials/tokenPaymaster).
- [Batch execute contract calls]() with a single signature.

But beyond offering just the functionality provided by the Bundlers and
Paymasters, MEEs offer a plethora of new features, with users being able to:

- [Share gas across chains]().
- [Execute Intents]().
- Execute [multiple transactions on multiple chains]() with a signle signature.
- Orhcestrate [complex transaction sequences]() which span multiple blockchains.
- [Batch execute with EOAs]().
- [Compose contract calls]() across chains.
- [Dynamically inject outputs of bridges and solvers]() into function calls.

## Modular Execution Environment

Our Modular Execution Environment, powered by the permisionless [Biconomy Network](https://asd.com), enables developers
to build fully chain-abstracted user experiences and to effortlessly build apps which access users, funds and liquidity
across multiple blockchains.

### Supertransaction

The base of MEE is the Supertransaction data model. Supertransactions enable developers to encode multiple transactions and
intents into a single data model. This entire complex series of instructions is represented by a single `hash`. 

By signing the Supertransaction hash - the user permits all of those 
instructions to be executed by MEE Nodes.

```ts
// Encode a Supertransaction
const supertx: SuperTransaction = {
  instructions: [
    // Send USDC on Optimsim
    mcUSDC.on(optimism.id).transfer({
      args: [recipient, sendAmount],
      gasLimit: 100_000n
    }),
    // Send USDT on Base
    mcUSDT.on(base.id).transfer({
      args: [recipient, sendAmount],
      gasLimit: 100_000n
    })
  ],
  // Pay for gas with USDC on Polygon
  feeToken: toFeeToken({ token: mcUSDC, chain: polygon })
}

// Execute everything with a single signature
await executeQuote(meeClient, {
  quote: await getQuote(meeClient, stx)
})
```
![Supertx](https://d3e0luujhwn38u.cloudfront.net/resized/1gCQ1yzpbiG5ncnAOaw-lAm8ZuFQN1jwvSWfn5lka1Q/s:3200/plain/s3://typefully-user-uploads/img/original/186833/ab861f2c-6080-4fca-862c-26d256b75099.png)

### Advanced Gas Abstraction

Users can pay for execution on one chain with native or ERC20 tokens on another
chain.

:::tip[Example]
A user is executing a `swap` transaction on `Optimism` and pays for execution
with `USDC` on `Base`
:::

```ts
const supertx: Supertransaction = {
  instructions: [
    // Send USDC on Optimism
    mcUSDC.on(optimism).transfer({
      args: [...]
      //... 
    })
  ],
  // Pay for gas with USDT on Base
  feeToken: toFeeToken({
    token: mcUSDT,
    chain: base
  })
}
```

### Execute Intents

Intent based execution has enabled instant cross-chain liqudity fronting. If a user has funds on Optimsim and Base, but needs
to call a contract on Polygon - they can use intent networks and solvers to quickly move the funds to the target chain.

MEEs enable users to combine intents (for quickly getting funds on the target chains) with transactions (for precisely
defining which contacts to call on the target chain).

[Learn How to Execute Intents](/mee/tutorials/execute-intent)

```ts
// Move 100 USDC to Optimsim
const intent = await prepareIntent({
  account: mcNexus,
  amount: parseUnits('100', 6),
  toChain: optimism,
  token: mcUSDC
})

// Execute intent
await executeQuote(meeClient, {
  quote: await getQuote(meeClient, {
    instructions: [intent],
    feeToken: toFeeToken({token: mcUSDC, chain: base})
  })
})
```

### Batch Execute Large Transaction Bundles

Since MEE Nodes can execute an arbitrary number of transactions with a 
single gas payment and a single signature - they're not limited by the 
`blockGasLimit` so can be used for bulk executing very large bundles of 
transactions.

Here is an example of sending 100 USDC a thousand times. 

```ts
const thousandRecipients: Address[] = Array(1000).fill(zeroAddress)

const supertx: SuperTransaction = {
  instructions: [
    // Execute `transfer` a 1000 times
    ...thousandRecipients.map(recipient =>
      mcUSDC.on(optimism.id).transfer({
        args: [recipient, parseUnits('100', 6)],
        gasLimit: 100000n
      })
    )
  ],
  // Pay for gas once with USDC on Optimism
  feeToken: toFeeToken({
    chain: optimism,
    token: mcUSDC
  })
}
```

### Multichain Orchestration

MEE enables the execution of multiple transactions on multiple chains - with a single user signature. The developer simply
needs to encode a series of transactions which need to be executed - e.g. Swap USDT to USDC on Polygon, bridge USDC to Base
and, once it arrives, use the exact amount which arrived to supply to a Morpho Lending Pool. The entire transaction is
automatically orchestrated by the MEE network.

## Compatibility

:::info
**Note**

If you're already building with ERC4337 - transitioning to
MEE is effotless and requries no code changes on your side. You can simply add MEE execution where it fits, while keeping
the ERC4337 code base in the same project. You can add MEE to projects powered by both Biconomy or alternative ERC4337 infra
providers.
:::

## Code Highlight - Orchestrating A Multichain Transaction with Cross-Chain Gas Abstraction

This is an example of a Supertransaction enabled by the Modular Execution Environment. This operation will:

1. Pull funds from multiple chains to a single target chain
2. Wait for all the funds to arrive on the target chain
3. Automatically orchestrate a batch execution of `approve` + `supply`

This entire Supertransaction is permitted by a single signature from the user and is automtatically
orchestrated and executed by our MEE infrastructure.

MEE will make sure that all the conditions are met on the destination chain before proceeding to execute the
approve and supply transactions, there is no manual management of transaction dependencies by the developer

:::info
This is not a full code example. To start implementing plase refer to [MEE Quickstart](/mee/mee) or
[AA Quickstart](/quickstart). Not sure where to start? Read our [Choosing Infrastructure Guice](/mee/mee)
:::

```typescript
// Move user funds from multiple chains to a single
// destination chain and execute a supply to AAVE on that
// chain. All executed with a single signature.
const sTx = supertransaction({
  account: mcNexus, // Multichain Smart Account
  feeToken: mcUSDC.on(base), // Pay gas with USDC on Base
  instructions: [
    // Encode liquidity fronting from multiple chains
    await requireERC20Balance({
      token: mcUSDC,
      chain: optimism,
      providedAmount: supplyAmount,
    }),
    // Approve USDC to AAVE
    mcUSDC.write({
      chain: optimism,
      functionName: "approve",
      args: [
        mcAAVE.deploymentOn(optimism),
        inTimeBalanceOf(mcUSDC), // Adjust for slippage with bridging
      ],
    }),
    // Supply to AAVE
    mcAAVE.write({
      chain: optimism,
      functionName: "supply",
      args: [
        mcUSDC.addressOn(optimism),
        inTimeBalanceOf(mcUSDC),
        zeroAddress,
        0,
      ],
    }),
  ],
});

// Execute with a single user signature
const result = await meeService.execute(
  await signMeeQuote({
    executionMode: "direct-to-mee",
    quote,
    signer,
  })
);

console.log("Supertransaction hash:", result.hash);
```
